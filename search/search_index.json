{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>ProfileStore is a Roblox DataStore wrapper that streamlines auto-saving, session locking and a few other features for the game developer. ProfileStore's source code runs on a single ModuleScript.</p> <p>If you want to save time writing code for player data caching or want to prevent item \"duping\" in a game with trading - this can be a helpful resource!</p> <p>\ud83d\udcb2\ud83d\udcb2\ud83d\udcb2 Consider donating R$ to the creator of ProfileStore (Click here) if you find this resource helpful!</p> <p>If you need help integrating ProfileStore into your project, join the discussion on the Roblox forums (Click here).</p> <p>Forward any bugs to the creator of this module - we'll try to fix bugs super quickly!</p>"},{"location":"#how-does-it-work","title":"How does it work?","text":"<p>ProfileStore loads and caches data from a DataStore key on a single Roblox game server and prevents other game servers from accessing this data too soon by establishing a session lock and handling session lock conflicts between servers swiftly all while not using too many DataStore and MessagingService API calls.</p> <p>Data units saved by ProfileStore are called \"profiles\" which can be accessed in-game by starting a \"session\". During an active session you gain access to a table (<code>Profile.Data</code>) which will either be saved to the DataStore on the next auto-save or when you manually end the session.</p> <p>ProfileStore is primarily player-data-oriented and, by design, tweaked for a common use case where each game player would have a single profile dedicated to storing their game progress. Session locking addresses the issue of data access from more than one game server (which can cause item \"dupes\" in games with trading) by keeping track of which game server is currently caching data and gracefully switches ownership from one server to the other without failing new session requests. ProfileStore can still be used for non-player data storage, although ProfileStore's session locking is not ideal for quick writing from several game servers.</p> <p>ProfileStore's module functions try to resemble the Roblox API for a sense of familiarity to Roblox developers. Methods with the <code>Async</code> keyword yield until a result is ready (e.g. <code>:StartSessionAsync()</code>), while others do not.</p> <p>ProfileStore is not designed (and never will be) for in-game leaderboards or any kind of global state.</p>"},{"location":"#changes-from-profileservice","title":"Changes from ProfileService","text":"<p>ProfileStore is a successor to ProfileService - it uses a very similar mechanism for handling session locks which has been improved to be more responsive at handling conflicts between servers. Here's a list of significant changes:</p> <ul> <li> <p>Default auto-save period increased from 30 to 300 seconds - Nearly x10 fewer DataStore calls consume less server resources which means more scalability! ProfileStore relies on auto-saves to store latest data and resolve session conflicts in a single <code>:UpdateAsync()</code> call. With the addition of MessagingService, ProfileStore can now auto-save slower while still reacting to external game servers trying to take the session lock. Under normal circumstances ProfileStore should outperform ProfileService in session conflict resolution time!</p> </li> <li> <p>More performance, more server-friendly - <code>MessagingService</code>  helps resolve session conflicts much faster. ProfileStore also tries to strain Roblox services less when things inevitably do go wrong with exponential backoff, timeouts and cancel conditions.</p> </li> <li> <p>Outdated 7 second DataStore queue replaced - An internal DataStore API call queue is needed to ensure calls are satisfied in order. Roblox DataStores have changed since ProfileService was released and the 7 second queue was replaced with a queue that performs calls to the same DataStore key as soon as all previous calls finish.</p> </li> <li> <p>Luau types for autocompletion - This will help make fewer typos while writing code with ProfileStore.</p> </li> <li> <p>API cleanup - Function and variable names have been changed to be shorter and more conventional.</p> </li> <li> <p><code>MetaTags</code> removed in favor of <code>Profile.LastSavedData</code> - MetaTags has been a piece of data exclusively used to verify data that has been successfully saved to the DataStore. <code>Profile.LastSavedData</code> will also satisfy this purpose - every time <code>Profile.Data</code> is saved to the DataStore, <code>Profile.LastSavedData</code> will be updated with the version of <code>Profile.Data</code> that has been successfully saved to the DataStore.</p> </li> <li> <p>New profile messaging system replacing <code>GlobalUpdates</code> - GlobalUpdates was a complicated system for writing to profiles regardless of whether a server is currently running a session for them. <code>ProfileStore:MessageAsync()</code> is much easier to use and has fast delivery time by utilizing MessagingService. Use this for features like in-game player gifting where data delivery is crucial.</p> </li> <li> <p><code>Profile.OnSave</code>, <code>Profile.OnLastSave</code> and <code>Profile.OnAfterSave</code> signals - Useful for altering and reacting to data along ProfileStore's DataStore requests.</p> </li> </ul>"},{"location":"#should-i-switch-from-profileservice-the-older-module","title":"Should I switch from ProfileService (the older module)?","text":"<p>It might be a good idea to let old projects keep using ProfileService and start using ProfileStore for brand new ones, but if you're feeling risky...</p> <p>ProfileStore DataStore profiles are backwards-compatible with ProfileService! ProfileService profiles should load from the DataStore using the same keys in ProfileStore without issue, but ProfileService (the older module) might have issues loading the same profiles again if you start using <code>ProfileStore:MessageAsync()</code> (on the new module). You should first do Roblox studio tests with API access before pushing this change live.</p>"},{"location":"api/","title":"API","text":"<p>Notice</p> <p>Methods with <code>Async</code> in their name are methods that will yield - similar to how <code>task.wait()</code> is a function that yields</p>"},{"location":"api/#module","title":"Module","text":""},{"location":"api/#isclosing","title":".IsClosing","text":"<p><pre><code>ProfileStore.IsClosing   [bool] (read-only)\n</code></pre> When the Roblox is shutting down this value will be set to <code>true</code> and most methods will silently fail.</p>"},{"location":"api/#iscriticalstate","title":".IsCriticalState","text":"<p><pre><code>ProfileStore.IsCriticalState   [bool] (read-only)\n</code></pre> After an excessive amount of DataStore calls fail this value will temporarily be set to <code>true</code> until the DataStore starts operating normally again. Might be useful for analytics or notifying players in-game of possible service disturbances.</p>"},{"location":"api/#onerror","title":".OnError","text":"<p><pre><code>ProfileStore.OnError   [Signal] (message, store_name, profile_key)\n</code></pre> A signal for DataStore error logging. Example: <pre><code>ProfileStore.OnError:Connect(function(error_message, store_name, profile_key)\n  print(`DataStore error (Store:{store_name};Key:{profile_key}): {error_message}`)\nend)\n</code></pre></p>"},{"location":"api/#onoverwrite","title":".OnOverwrite","text":"<p><pre><code>ProfileStore.OnOverwrite   [Signal] (store_name, profile_key)\n</code></pre> A signal for events when a DataStore key returns a value that has all or some of it's profile components set to invalid data types. E.g., accidentally setting <code>Profile.Data</code> to a non table value. Example: <pre><code>ProfileStore.OnOverwrite:Connect(function(store_name, profile_key)\n  print(`Overwrite has occurred for Store:{store_name}, Key:{profile_key}`)\nend)\n</code></pre></p>"},{"location":"api/#oncriticaltoggle","title":".OnCriticalToggle","text":"<p><pre><code>ProfileStore.OnCriticalToggle   [Signal] (is_critical)\n</code></pre> A signal that is called whenever <code>ProfileStore.IsCriticalState</code> changes. Example: <pre><code>ProfileStore.OnCriticalToggle:Connect(function(is_critical)\n  if is_critical == true then\n    print(`ProfileStore entered critical state`)\n  else\n    print(`ProfileStore critical state is over`)\n  end\nend)\n</code></pre></p>"},{"location":"api/#datastorestate","title":".DataStoreState","text":"<p><pre><code>ProfileStore.DataStoreState   [string] \"NotReady\" | \"NoInternet\" | \"NoAccess\" | \"Access\"\n</code></pre> Indicates ProfileStore's access to the DataStore. If at first check <code>ProfileStore.DataStoreState</code> is <code>\"NotReady\"</code>, it will eventually change to one of the other 3 possible values (<code>NoInternet</code>, <code>NoAccess</code> or <code>Access</code>) and never change again. <code>\"Access\"</code> means ProfileStore can write to the DataStore.</p>"},{"location":"api/#new","title":".New()","text":"<p><pre><code>ProfileStore.New(store_name, template?) --&gt; [ProfileStore]\n  -- store_name   [string] -- DataStore name\n  -- template     nil or [table] -- Profile.Data will default\n    -- to given table (deep-copy) when no data was saved previously\n</code></pre> <code>ProfileStore</code> objects expose methods for reading and writing to profiles. Equivalent of :GetDataStore() in Roblox DataStoreService API.</p> <p>Notice</p> <p>By default, <code>template</code> is only copied for <code>Profile.Data</code> for new profiles. Changes made to <code>template</code> can be applied to <code>Profile.Data</code> of previously saved profiles by calling Profile:Reconcile(). Using templates and reconciliation is completely optional and you may alter <code>Profile.Data</code> with your own code alone.</p>"},{"location":"api/#setconstant","title":".SetConstant()","text":"<p><pre><code>ProfileStore.SetConstant(name, value)\n  -- name    [string] \"AUTO_SAVE_PERIOD\" | \"LOAD_REPEAT_PERIOD\" | \"FIRST_LOAD_REPEAT\" | \"SESSION_STEAL\"\n|   -- \"ASSUME_DEAD\" | \"START_SESSION_TIMEOUT\" | \"CRITICAL_STATE_ERROR_COUNT\" | \"CRITICAL_STATE_ERROR_EXPIRE\"\n|   -- \"CRITICAL_STATE_EXPIRE\" | \"MAX_MESSAGE_QUEUE\"\n  -- value   [number]\n</code></pre> A feature for experienced developers who understand how ProfileStore works for changing internal constants without having to fork the ProfileStore project.</p>"},{"location":"api/#profilestore","title":"ProfileStore","text":""},{"location":"api/#mock","title":".Mock","text":"<pre><code>local PlayerStore = ProfileStore.New(\"PlayerData\", {})\n\n-- This profile would be saved to the DataStore:\nlocal LiveProfile = PlayerStore:StartSessionAsync(\"profile_key\")\nLiveProfile.Data.Value = 1\nLiveProfile:EndSession()\n\n-- This profile does not load data from the DataStore\n-- nor save data to the DataStore:\n-- (This data will disappear after the game server shuts down)\nlocal MockProfile = PlayerStore.Mock:StartSessionAsync(\"profile_key\")\nMockProfile.Data.Value = 1\nMockProfile:EndSession()\n</code></pre> <p><code>ProfileStore.Mock</code> is a reflection of methods available in the <code>ProfileStore</code>, but said methods will now operate on profiles stored on a separate \"fake\" DataStore that will be forgotten when the game server shuts down. Profiles loaded using the same key from <code>ProfileStore</code> and <code>ProfileStore.Mock</code> will be different profiles because the regular and mock versions of a <code>ProfileStore</code> are isolated from each other.</p> <p><code>ProfileStore.Mock</code> is useful for customizing your testing environment in cases where you want to enable Roblox API services in studio, but don't want ProfileStore to save to live keys: <pre><code>local RunService = game:GetService(\"RunService\")\nlocal PlayerStore = ProfileStore.New(\"PlayerData\", {})\nif RunService:IsStudio() == true then\n  PlayerStore = PlayerStore.Mock\nend\n</code></pre></p> <p>Notice</p> <p>Even when Roblox API services are unavailable, <code>ProfileStore</code> and <code>ProfileStore.Mock</code> will store profiles separately from each other.</p>"},{"location":"api/#name","title":".Name","text":"<p><pre><code>ProfileStore.Name   [string] (read-only)\n</code></pre> The name of the DataStore that was defined as the first argument of <code>ProfileStore.New()</code>.</p>"},{"location":"api/#startsessionasync","title":":StartSessionAsync()","text":"<p><pre><code>ProfileStore:StartSessionAsync(profile_key, params?) --&gt; [Profile] or nil\n  -- profile_key   [string] -- DataStore key\n  -- params        nil or [table]: {\n  --    Cancel: fn() -&gt; (boolean)?\n  --    Steal: boolean?\n  -- }\n</code></pre> Starts a session for a profile. If other servers call this method using the same <code>profile_key</code> they would notify the server that currently owns the session to make a final save before letting another server acquire the session. While a session is active you can expect any changes to <code>Profile.Data</code> to be saved. You can find out whether a session has ended by checking <code>Profile:IsActive() == true</code> or by listening to <code>Profile.OnSessionEnd</code>. You must always call <code>Profile:EndSession()</code> after you're done working with a profile as failing to do so will make the game perform more and more DataStore requests.</p> <p>The second optional argument to <code>ProfileStore:StartSessionAsync()</code> is a table with additional rules for the session start request:</p> <ul> <li><code>Cancel</code> - If set to a function, the function will be called several times by ProfileStore to check whether the profile session is still needed. If the profile is no longer needed, the <code>Cancel</code> function should return <code>true</code>. The <code>Cancel</code> argument would be useful in rare cases where the DataStores are unresponsive and a player leaves before a session was started allowing ProfileStore to stop making additional requests to the DataStore. Using the <code>Cancel</code> argument also disables the default ProfileStore session start timeout as the developer would decide when the profile is no longer needed.</li> <li><code>Steal</code> - (e.g. <code>{Steal = true}</code>) If set to <code>true</code>, doesn't let an active session make final changes to <code>Profile.Data</code> and immediately starts a session on the server calling <code>ProfileStore:StartSessionAsync()</code> with this argument. DO NOT USE THIS ARGUMENT FOR LOADING PLAYER DATA NORMALLY - The <code>Steal</code> argument bypasses session locks which are needed for item \"dupe\" prevention. This argument is only useful for debugging.</li> </ul> <p>The <code>Steal</code> argument bypasses session locks which are needed for item \"dupe\" prevention - use this only if you know what you are doing</p> <p>Example usage: <pre><code>local Players = game:GetService(\"Players\")\nlocal profile = PlayerStore:StartSessionAsync(tostring(player.UserId), {\n  Cancel = function()\n    return player:IsDescendantOf(Players) == false\n  end,\n})\n</code></pre></p> <p>Notice</p> <p>ProfileStore saves profiles to live DataStore keys in Roblox Studio when Roblox API services are enabled. See ProfileStore.Mock if saving to live keys during testing is not desired.</p> <p>Warning</p> <p><code>:StartSessionAsync()</code> can return <code>nil</code> when another remote Roblox server attempts to start a session for the same profile at the same time. This case should be extremely rare and it would be recommended to :Kick() the player if <code>:StartSessionAsync()</code> does not return a <code>Profile</code> object.</p>"},{"location":"api/#messageasync","title":":MessageAsync()","text":"<p><pre><code>ProfileStore:MessageAsync(profile_key, message) --&gt; is_success [bool]\n  -- profile_key   [string] -- DataStore key\n  -- message       [table] -- Data to be stored in the profile before it's received\n</code></pre> Sends a message to a profile regardless of whether a server has started a session for it. Each <code>ProfileStore:MessageAsync()</code> call will use one :UpdateAsync() call for sending the message and another :UpdateAsync() call on the server that currently has a session started for the profile - This means that <code>ProfileStore:MessageAsync()</code> is only to be used for when handling critical data like gifting paid items to in-game friends that may or may not be online at the moment. If you don't mind the possibility of your messages failing to deliver, use MessagingService instead. See <code>Profile:MessageHandler()</code> to learn how to receive messages.</p>"},{"location":"api/#getasync","title":":GetAsync()","text":"<p><pre><code>ProfileStore:GetAsync(profile_key, version?) --&gt; [Profile] or nil\n  -- profile_key   [string]\n  -- version       nil or [string] -- DataStore key version\n</code></pre> Attempts to load the latest profile version (or a specified version via the <code>version</code> argument) from the DataStore without starting a session. Returned <code>Profile</code> will not auto-save and you won't have to call <code>:EndSession()</code> for it. Data in the returned <code>Profile</code> can be edited to create a payload which can be saved via Profile:SetAsync(). If there's no data saved in the DataStore under a provided <code>profile_key</code>, <code>ProfileStore:GetAsync()</code> will return <code>nil</code>.</p> <p><code>:GetAsync()</code> is the the preferred way of reading player data without editing it.</p> <p><code>Profile.Data</code> will not be auto-saved when using <code>ProfileStore:GetAsync()</code></p>"},{"location":"api/#versionquery","title":":VersionQuery()","text":"<p><pre><code>ProfileStore:VersionQuery(profile_key, sort_direction?, min_date?, max_date?) --&gt; [VersionQuery]\n  -- profile_key      [string]\n  -- sort_direction   nil or [Enum.SortDirection] -- Defaults to \"Ascending\"\n  -- min_date         nil or [DateTime] or [number] (epoch time millis)\n  -- max_date         nil or [DateTime] or [number] (epoch time millis)\n</code></pre> Creates a profile version query using DataStore:ListVersionsAsync() (Official documentation). Results are retrieved through <code>VersionQuery:NextAsync()</code>. Date definitions are easier with the DateTime (Official documentation) library. User defined day and time will have to be converted to Unix time (Wikipedia) while taking their timezone into account to expect the most precise results, though you can be rough and just set the date and time in the UTC timezone and expect a maximum margin of error of 24 hours for your query results.</p> <p>Examples of query arguments:</p> <ul> <li>Pass <code>nil</code> for <code>sort_direction</code>, <code>min_date</code> and <code>max_date</code> to find the oldest available version</li> <li>Pass <code>Enum.SortDirection.Descending</code> for <code>sort_direction</code>, <code>nil</code> for <code>min_date</code> and <code>max_date</code> to find the most recent version.</li> <li>Pass <code>Enum.SortDirection.Descending</code> for <code>sort_direction</code>, <code>nil</code> for <code>min_date</code> and <code>DateTime</code> defining a time before an event     (e.g. two days earlier before your game unrightfully stole 1,000,000 coins from a player) for <code>max_date</code> to find the most recent     version of a <code>Profile</code> that existed before said event.</li> </ul> <p>Case example: \"I lost all of my coins on August 14th!\"</p> <pre><code>-- Get a ProfileStore object with the same arguments you passed to the\n--  ProfileStore that loads player Profiles:\n\nlocal PlayerStore = ProfileStore.New(\"PlayerData\", {})\n\n-- If you can't figure out the exact time and timezone the player lost coins\n--  in on the day of August 14th, then your best bet is to try querying\n--  UTC August 13th. If the first entry still doesn't have the coins - \n--  try a new query of UTC August 12th and etc.\n\nlocal max_date = DateTime.fromUniversalTime(2021, 08, 13) -- UTC August 13th, 2021\n\nlocal query = PlayerStore:VersionQuery(\n  \"Player_2312310\", -- The same profile key that gets passed to :LoadProfileAsync()\n  Enum.SortDirection.Descending,\n  nil,\n  max_date\n)\n\n-- Get the first result in the query:\nlocal profile = query:NextAsync()\n\nif profile ~= nil then\n\n  profile:SetAsync() -- This method does the actual rolling back;\n    -- Don't call this method until you're sure about setting the latest\n    -- version to a copy of the previous one\n\n  print(`Rollback success!`)\n\n  print(profile.Data) -- You'll be able to surf table contents if\n    -- you're running this code in studio with access to API services\n    -- enabled and have expressive output enabled; If the printed\n    -- data doesn't have the coins, you'll want to change your\n    -- query parameters.\n\nelse\n  print(`No version to rollback to`)\nend\n</code></pre> <p>Case example: Studying data mutation over time</p> <pre><code>-- You have ProfileStore working in your game. You join\n--  the game with your own account and go to https://www.unixtimestamp.com\n--  and save the current UNIX timestamp resembling present time.\n--  You can then make the game alter your data by giving you\n--  currency, items, experience, etc.\n\nlocal PlayerStore = ProfileStore.New(\"PlayerData\", {})\n\n-- UNIX timestamp you saved:\nlocal min_date = DateTime.fromUnixTimestamp(1628952101)\nlocal print_minutes = 60 * 12 -- Print the next 12 hours of history\n\nlocal query = PlayerStore:VersionQuery(\n  \"Player_2312310\",\n  Enum.SortDirection.Ascending,\n  min_date\n)\n\n-- You can now attempt to print out every snapshot of your data saved\n--  at an average periodic interval of 60 minutes (Roblox DataStore caching interval)\n--  starting from the time you took the UNIX timestamp!\n\nlocal finish_update_time = min_date.UnixTimestampMillis + (print_minutes * 60000)\n\nprint(`Fetching {print_minutes} minutes of saves:`)\n\nlocal entry_count = 0\n\nwhile true do\n\n  entry_count +=1\n  local profile = query:NextAsync()\n\n  if profile ~= nil then\n\n    if profile.KeyInfo.UpdatedTime &gt; finish_update_time then\n      if entry_count == 1 then\n        print(`No entries found in set time period. (Start timestamp too early)`)\n      else\n        print(`Time period finished.`)\n      end\n      break\n    end\n\n    print(`Entry {entry_count} - {DateTime.fromUnixTimestampMillis(profile.KeyInfo.UpdatedTime):ToIsoDate()}`)\n\n    print(profile.Data) -- Printing table for studio expressive output\n\n  else\n    if entry_count == 1 then\n      print(`No entries found in set time period. (Start timestamp too late)`)\n    else\n      print(`No more entries in query.`)\n    end\n    break\n  end\n\nend\n</code></pre>"},{"location":"api/#removeasync","title":":RemoveAsync()","text":"<p><pre><code>ProfileStore:RemoveAsync(profile_key) --&gt; is_success [bool]\n  -- profile_key   [string] -- DataStore key\n</code></pre> You can use <code>:RemoveAsync()</code> to erase data from the DataStore. In live Roblox servers <code>:RemoveAsync()</code> must be used on profiles created through <code>ProfileStore.Mock</code> after <code>Profile:EndSession()</code> and it's known that the <code>Profile</code> will no longer be loaded again.</p>"},{"location":"api/#profile","title":"Profile","text":""},{"location":"api/#data","title":".Data","text":"<p><pre><code>Profile.Data   [table]\n</code></pre> This is the data that would resemble player progress or other data you wish to save to the DataStore. Changes to <code>Profile.Data</code> are guaranteed to save as long as you do so after checking for the condition <code>Profile:IsActive() == true</code> or before the signal <code>Profile.OnSessionEnd</code> is triggered. The result of <code>Profile:IsActive()</code> can change at any moment, so critical data should be stored to <code>Profile.Data</code> immediately after checking without yielding (e.g. <code>task.wait()</code>). If needed, you may set <code>Profile.Data</code> to a new table reference (e.g. <code>Profile.Data = {}</code>). When <code>Profile:IsActive()</code> returns <code>false</code> changes to <code>Profile.Data</code> are no longer stored to the DataStore.</p>"},{"location":"api/#lastsaveddata","title":".LastSavedData","text":"<p><pre><code>Profile.LastSavedData   [table] (read-only)\n</code></pre> This is a version of <code>Profile.Data</code> that has been successfully stored to the DataStore. Useful for verifying what particular data has been saved, or for securely handling developer product purchases.</p>"},{"location":"api/#firstsessiontime","title":".FirstSessionTime","text":"<p><pre><code>Profile.FirstSessionTime   [number] (read-only) -- Unix time\n</code></pre> A Unix timestamp of when the profile was created.</p>"},{"location":"api/#sessionloadcount","title":".SessionLoadCount","text":"<p><pre><code>Profile.SessionLoadCount   [number] (read-only)\n</code></pre> Amount of times a session has been started for this profile.</p>"},{"location":"api/#session","title":".Session","text":"<p><pre><code>Profile.Session   [table?] (read-only) -- nil or {PlaceId = number, JobId = string}\n</code></pre> This value never changes after a profile object is created. After you start a session for a profile, the <code>Profile.Session</code> will be equal to a <code>table</code> with it's <code>PlaceId</code> and <code>JobId</code> members set to the server you started the session on. After you read a profile using ProfileStore:GetAsync(), <code>Profile.Session</code> may be equal to <code>nil</code> or a <code>table</code> with it's <code>PlaceId</code> and <code>JobId</code> members set to the server that currently has a session started for the profile.</p>"},{"location":"api/#robloxmetadata","title":".RobloxMetaData","text":"<pre><code>Profile.RobloxMetaData   [table]\n</code></pre> <p>Be cautious of very harsh limits for maximum Roblox Metadata size - As of writing this, total table content size cannot exceed 300 characters.</p> <p>A table that gets saved as Metadata (Official documentation) of a DataStore key belonging to the profile. The way this table is saved is equivalent to using <code>DataStoreSetOptions:SetMetaData(Profile.RobloxMetaData)</code> and passing the <code>DataStoreSetOptions</code> object to a <code>:SetAsync()</code> call, except changes will truly get saved on the next auto-save cycle or when the profile session is ended. Info on Roblox metadata limits can be found here.</p>"},{"location":"api/#userids","title":".UserIds","text":"<p><pre><code>Profile.UserIds [table] (read-only) -- {user_id [number], ...}\n</code></pre> User ids associated with this profile. Entries must be added with Profile:AddUserId() and removed with Profile:RemoveUserId().</p>"},{"location":"api/#keyinfo","title":".KeyInfo","text":"<p><pre><code>Profile.KeyInfo [DataStoreKeyInfo]\n</code></pre> The DataStoreKeyInfo (Official documentation) instance related to this profile.</p>"},{"location":"api/#onsave","title":".OnSave","text":"<p><pre><code>Profile.OnSave:Connect(function()\n  print(`Profile.Data is about to be saved to the DataStore`)\nend)\n</code></pre> A signal that is fired right before whenever changes to <code>Profile.Data</code> are saved to the DataStore. Changes to <code>Profile.Data</code> are expected to save when done at the moment of <code>Profile.OnSave</code> firing, but this guarantee is no longer valid after yielding (e.g. using <code>task.wait()</code> or <code>:WaitForChild()</code>) and the condition <code>Profile:IsActive() == true</code> would have to be used instead. <code>Profile.OnSave</code> will be fired before every auto-save, before a manual save caused by <code>Profile:Save()</code> and before a final save after a session has been ended.</p>"},{"location":"api/#onlastsave","title":".OnLastSave","text":"<p><pre><code>Profile.OnLastSave:Connect(function(reason: \"Manual\" | \"External\" | \"Shutdown\")\n  print(`Profile.Data is about to be saved to the DataStore for the last time; Reason: {reason}`)\nend)\n</code></pre> A signal that is fired right before changes to <code>Profile.Data</code> are saved to the DataStore for the last time. Changes to <code>Profile.Data</code> are expected to save when done at the moment of <code>Profile.OnLastSave</code> firing, but this guarantee is no longer valid after yielding (e.g. using <code>task.wait()</code> or <code>:WaitForChild()</code>). <code>Profile.OnLastSave</code> will be fired after a session has ended in one of three ways:</p> <ul> <li><code>\"Manual\"</code> - Developer code called <code>Profile:EndSession()</code></li> <li><code>\"External\"</code> - Another server started a session for the same profile</li> <li><code>\"Shutdown\"</code> - The profile session has been ended automatically due to the server shutting down</li> </ul> <p>One of <code>Profile.OnLastSave</code> uses is giving \"logout penalties\" where a player may receive punishment for closing the game at the wrong time. Example: <pre><code>local InCombat = false\n\nProfile.OnLastSave:Connect(function(reason)\n  if reason ~= \"Shutdown\" then\n\n    print(`The cause of the session ending is not due to a server shutdown`)\n\n    -- If you didn't want the player to logout at this particular moment,\n    -- this should be where you'd penalize the player. e.g.:\n\n    if InCombat == true then\n      Profile.Data.Coins -= 100\n    end\n\n  end\nend)\n</code></pre></p> <p>Warning</p> <p>On rare occasions Roblox servers can crash and <code>Profile.OnLastSave</code> might never get the chance to fire. You should design your data saving code in a way where reacting to <code>Profile.OnLastSave</code> is not critical.</p>"},{"location":"api/#onsessionend","title":".OnSessionEnd","text":"<p><pre><code>Profile.OnSessionEnd:Connect(function()\n  print(`Profile session has ended - Profile.Data will no longer be saved to the DataStore`)\nend)\n</code></pre> The <code>Profile.OnSessionEnd</code> signal can be fired after the developer calls <code>Profile:EndSession()</code>, Another server calls [<code>ProfileStore:StartSessionAsync()</code>] for the same profile or when the server is shutting down. After the <code>Profile.OnSessionEnd</code> signal is fired, no further changes to <code>Profile.Data</code> should be made. <code>Profile.OnSessionEnd</code> will fire even when a profile session is stolen, whereas <code>Profile.OnLastSave</code> would not. In some cases it would be preferable to kick the player from the game when this signal is fired:</p> <pre><code>Profile.OnSessionEnd:Connect(function()\n  player:Kick(`Your data has been loaded on another server - please rejoin`)\nend)\n</code></pre> <p>Warning</p> <p><code>Profile.OnSessionEnd</code> should not be used for applying final changes to <code>Profile.Data</code>. Use <code>Profile.OnLastSave</code> instead.</p>"},{"location":"api/#onaftersave","title":".OnAfterSave","text":"<p><pre><code>Profile.OnAfterSave:Connect(function(last_saved_data)\n  print(`Profile.Data has been successfully saved to the DataStore:`, last_saved_data)\nend)\n</code></pre> This signal will fire every time after profile data has been accessed by <code>GlobalDataStore:UpdateAsync()</code>. After this signal is fired, the values <code>Profile.LastSavedData</code> and <code>Profile.KeyInfo</code> will have been changed - <code>Profile.LastSavedData</code> can be used to verify which particular changes to <code>Profile.Data</code> have been successfully saved to the DataStore.</p>"},{"location":"api/#profilestore_1","title":".ProfileStore","text":"<p><pre><code>Profile.ProfileStore   [ProfileStore] -- ProfileStore object this profile belongs to\n</code></pre> The <code>ProfileStore</code> object that was used to create this profile.</p>"},{"location":"api/#key","title":".Key","text":"<p><pre><code>Profile.Key   [string] -- DataStore key\n</code></pre> The DataStore key of this profile. This is the first passed argument to <code>ProfileStore:StartSessionAsync()</code> or <code>ProfileStore:GetAsync()</code>.</p>"},{"location":"api/#isactive","title":":IsActive()","text":"<p><pre><code>Profile:IsActive() --&gt; [bool]\n</code></pre> If  <code>Profile:IsActive()</code> returns <code>true</code>, changes to <code>Profile.Data</code> will be saved - this guarantee will no longer be valid after yielding (e.g. using <code>task.wait()</code> or <code>:WaitForChild()</code>). When implementing in-game trading, you may make changes to two profiles immediately without yielding after <code>Profile:IsActive()</code> returns <code>true</code> for the two profiles.</p>"},{"location":"api/#reconcile","title":":Reconcile()","text":"<p><pre><code>Profile:Reconcile()\n</code></pre> Fills in missing variables inside <code>Profile.Data</code> from a template table that was provided as a second argument to <code>ProfileStore.New()</code>. <code>Profile:Reconcile()</code> can be useful if you're making changes to your data template over the course of your game's development.</p>"},{"location":"api/#endsession","title":":EndSession()","text":"<p><pre><code>Profile:EndSession()\n</code></pre> Stops auto-saving for this profile and saves <code>Profile.Data</code> to the DataStore for the last time. Call this method after you're done working with the <code>Profile</code> object created by <code>ProfileStore:StartSessionAsync()</code>.</p> <p>Example: <pre><code>Players.PlayerRemoving:Connect(function(player)\n\n  local profile = Profiles[player]\n\n  if profile ~= nil then\n    profile:EndSession()\n    Profiles[player] = nil\n  end\n\nend)\n</code></pre></p>"},{"location":"api/#adduserid","title":":AddUserId()","text":"<p><pre><code>Profile:AddUserId(user_id)\n-- user_id [number]\n</code></pre> Associates a <code>UserId</code> with the profile. Multiple users can be associated with a single profile by calling this method for each individual <code>UserId</code>. The primary use of this method is to comply with GDPR (The right to erasure). More information in official documentation.</p>"},{"location":"api/#removeuserid","title":":RemoveUserId()","text":"<p><pre><code>Profile:RemoveUserId(user_id)\n-- user_id [number]\n</code></pre> Unassociates a <code>UserId</code> with the profile.</p>"},{"location":"api/#messagehandler","title":":MessageHandler()","text":"<p><pre><code>Profile:MessageHandler(function(message, processed)\n  print(`Message received:`, message)\n  processed()\nend)\n</code></pre> Sets a function that will handle existing and future incoming messages sent to this profile by <code>ProfileStore:MessageAsync()</code>. The <code>message</code> argument is a <code>table</code> that was passed as the second argument to <code>ProfileStore:MessageAsync()</code>. The <code>processed</code> argument is a function that must be called to let ProfileStore know this message has been processed. If a message is not processed by calling <code>processed()</code>, ProfileStore will continue to iterate through other functions passed to <code>Profile:MessageHandler()</code> and will broadcast the same <code>message</code>. Unprocessed messages will be broadcasted to new functions passed to <code>Profile:MessageHandler()</code> and will continue to do so when a profile session is started another time (e.g. after a player joins the game again) until <code>processed()</code> is finally called.</p>"},{"location":"api/#save","title":":Save()","text":"<p><pre><code>Profile:Save()\n</code></pre> Calling <code>Profile:Save()</code> will immediately save <code>Profile.Data</code> to the DataStore when a profile session is still active (<code>Profile:IsActive()</code> returns <code>true</code>). <code>Profile.Data</code> is already automatically saved to the DataStore on auto-saves and when the profile session is ended with <code>Profile:EndSession()</code>, so <code>Profile:Save()</code> should only be used for critical moments like ensuring data related to Developer Product purchases are saved before a server crash could occur. The cost of calling <code>Profile:Save()</code> is one :UpdateAsync() call - see the official documentation on DataStore limits to evaluate your use case.</p>"},{"location":"api/#setasync","title":":SetAsync()","text":"<pre><code>Profile:SetAsync()\n</code></pre> <p>Only works for profiles loaded through ProfileStore:GetAsync() or ProfileStore:VersionQuery()</p> <p>Saves <code>Profile.Data</code> of a profile loaded with ProfileStore:GetAsync() to the DataStore disregarding any active sessions. If there was a server that had an active session for that profile - that session will be ended.</p>"},{"location":"datause/","title":"DataStore Use","text":"<p>ProfileStore uses Roblox DataStores to store profile data. Roblox game servers have a limit on how many DataStore API requests can be made in a certain amount of time. You can find official information on Roblox DataStore limits by clicking here. ProfileStore also uses Roblox MessagingService to resolve session conflicts between multiple servers faster - Find information on Roblox MessagingService limits by clicking here.</p> <p>(During DataStore outages after a DataStore request results in an error ProfileStore may repeat requests faster or slower using exponential backoff)</p> <p>Certain operations you may perform using ProfileStore will use up a certain amount of Roblox API requests:</p>"},{"location":"datause/#on-startup-in-studio","title":"On startup in Studio","text":"<ul> <li>Uses 1 <code>:SetAsync()</code> call to check for DataStore API access.</li> </ul>"},{"location":"datause/#startsessionasync","title":"<code>:StartSessionAsync()</code>","text":"<p>Until a session is started:</p> <ul> <li>Usually uses 1 <code>:UpdateAsync()</code> call.</li> <li>If another server currently has a session started for the same profile, uses 1 <code>:UpdateAsync()</code> call and 1 <code>:PublishAsync()</code> call, then 5 seconds later (<code>FIRST_LOAD_REPEAT</code>) will perform 1 <code>:UpdateAsync()</code> call and 1  <code>:PublishAsync()</code> call. While the session conflict is not resolved, 1 <code>:UpdateAsync()</code> call and 1 <code>:PublishAsync()</code> call will be repeated in 10 second intervals (<code>LOAD_REPEAT_PERIOD</code>) for the next 40 seconds (<code>SESSION_STEAL</code>) until finally a session will be stolen (1 <code>:UpdateAsync()</code> call). Expect all of these calls to happen when players rejoin your game immediately after experiencing a server crash.</li> </ul> <p>After a session is started and until the session ends:</p> <ul> <li>Uses 1 <code>:UpdateAsync()</code> call in 300 second intervals (<code>AUTO_SAVE_PERIOD</code>). When <code>:Save()</code> is used, the 300 second timer will reset for this repeating call. This is the auto-save call.</li> <li>Subscribes to 1 <code>MessagingService</code> topic (1 <code>:SubscribeAsync()</code> call) - this topic subscription will be ended when the profile session ends.</li> </ul> <p>After <code>:EndSession()</code> is called OR another server starts a session for the same profile:</p> <ul> <li>Usually uses 1 <code>:UpdateAsync()</code> call.</li> <li>In rare cases will use 2 <code>:UpdateAsync()</code> calls in quick succession (1'st call - external session request detected; 2'nd call - locally broadcasting a final save and ending the session) when resolving a session conflict if a <code>MessagingService</code> message asking for a session end was not received on time.</li> </ul>"},{"location":"datause/#messageasync","title":"<code>:MessageAsync()</code>","text":"<ul> <li>Uses 1 <code>:UpdateAsync()</code> call and 1 <code>:PublishAsync()</code> call.</li> <li>If there's a server that currently has a session started for the targeted profile, 1 <code>:UpdateAsync()</code> call will be used on that server regardless of whether <code>:MessageAsync()</code> was called on the same server. The 300 second auto-save interval timer would also be reset in this scenario. ProfileStore does not assume developer code would immediately process a message sent by <code>:MessageAsync()</code> on the same server at all times, so instant storage of the message to the DataStore is prioritized to ensure data persistence.</li> </ul>"},{"location":"datause/#getasync","title":"<code>:GetAsync()</code>","text":"<ul> <li>Uses 1 <code>GlobalDataStore:GetAsync()</code> call.</li> </ul>"},{"location":"datause/#removeasync","title":"<code>:RemoveAsync()</code>","text":"<ul> <li>Uses 1 <code>GlobalDataStore:RemoveAsync()</code> call.</li> </ul>"},{"location":"datause/#versionquerynextasync","title":"<code>VersionQuery:NextAsync()</code>","text":"<ul> <li>May use 1 <code>:ListVersionsAsync()</code> call and may use 1 <code>GlobalDataStore:GetAsync()</code> call.</li> </ul>"},{"location":"datause/#save","title":"<code>:Save()</code>","text":"<ul> <li>Uses 1 <code>:UpdateAsync()</code> call.</li> </ul>"},{"location":"datause/#setasync","title":"<code>:SetAsync()</code>","text":"<ul> <li>Uses 1 <code>:UpdateAsync()</code> call.</li> </ul>"},{"location":"devproducts/","title":"Developer Products","text":"<p>This is a resource that can help you implement Developer Products into your Roblox game when you're also using ProfileStore.</p> <p>There are two ways you could handle Developer Product purchases - one way is based on the official Roblox documentation on handling developer product purchases, while the other way is based on observations on how Roblox MarketplaceService API works.</p> <p>In these examples <code>local Profiles</code> is a reference to the <code>Profiles</code> table in the Basic Usage example code - you will need to have this code present for the examples below to work!</p>"},{"location":"devproducts/#the-official-roblox-way","title":"The official Roblox way","text":"<p>(This is a Roblox official code example with alterations integrating ProfileStore)</p> <pre><code>local Profiles: {[player]: typeof(PlayerStore:StartSessionAsync())} = {} -- See Tutorial &gt; Basic Usage\n\nlocal MarketplaceService = game:GetService(\"MarketplaceService\")\nlocal Players = game:GetService(\"Players\")\n\nlocal productFunctions = {}\n\n-- Example: product ID 456456 awards 100 cash to the user\nproductFunctions[456456] = function(receipt, player, profile)\n    profile.Data.Cash += 100\n    -- We made changes to the player profile - perform an instant\n    -- save to secure a player purchase against server crashes:\n    profile:Save()\nend\n\n-- Example: product ID 123123 brings the user back to full health\nproductFunctions[123123] = function(receipt, player, profile)\n    local character = player.Character\n    local humanoid = character and character:FindFirstChildWhichIsA(\"Humanoid\")\n\n    if humanoid then\n        humanoid.Health = humanoid.MaxHealth\n        -- Indicates a successful purchase\n        return true\n    end\nend\n\nlocal function processReceipt(receiptInfo)\n    local userId = receiptInfo.PlayerId\n    local productId = receiptInfo.ProductId\n\n    local player = Players:GetPlayerByUserId(userId)\n    if player then\n\n        local profile = Profiles[player]\n\n        while profile == nil and player.Parent == Players do\n            profile = Profiles[player]\n            if profile ~= nil then\n                break\n            end\n            task.wait()\n        end\n\n        if profile ~= nil and profile:IsActive() == true then\n            -- Gets the handler function associated with the developer product ID and attempts to run it\n            local handler = productFunctions[productId]\n            local success, result = pcall(handler, receiptInfo, player, profile)\n            if success then\n                -- The user has received their items\n                -- Returns \"PurchaseGranted\" to confirm the transaction\n                return Enum.ProductPurchaseDecision.PurchaseGranted\n            else\n                warn(`Failed to process receipt:`, receiptInfo, result)\n            end\n        end\n\n    end\n\n    -- The user's items couldn't be awarded\n    -- Returns \"NotProcessedYet\" and tries again next time the user joins the experience\n    return Enum.ProductPurchaseDecision.NotProcessedYet\nend\n\n-- Sets the callback\n-- This can only be done once by one server-side script\nMarketplaceService.ProcessReceipt = processReceipt\n</code></pre>"},{"location":"devproducts/#another-way-caching-purchaseids","title":"Another way - Caching <code>PurchaseId</code>'s","text":"<p>Official Roblox documentation doesn't show a code example where the developer would delay returning a <code>Enum.ProductPurchaseDecision</code> result in the <code>MarketplaceService.ProcessReceipt</code> callback until it is known that the purchase has been successfully stored in the DataStore - this is not as relevant to immediate consumables like \"Buy this to kill everyone in this server\", but more relevant to consumables like in-game currency or even permanent perks. <code>MarketplaceService.ProcessReceipt</code> will continue requesting developer code to handle a product purchase even after a player rejoins the game after a while - the purchase handle request will provide a unique <code>PurchaseId</code> identifier which will stay consistent for a particular single purchase even after a player rejoins the game.</p> <p>At the moment of writing, observing <code>MarketplaceService.ProcessReceipt</code> behavior, we can see that it doesn't mind code yielding inside of it until a <code>Enum.ProductPurchaseDecision</code> result is returned - we can use this behavior to wait until we know data related to this purchase has been successfully saved by ProfileStore.</p> <p>If retaining player rewards for developer products is completely critical, it should be noted that the \"official Roblox way\" would fail to do so on a very rare condition where at a time of a developer product purchase all DataStore requests fail (or not even manage to happen on time) before the game server experiences a crash. This can be prevented by storing a cache of <code>PurchaseId</code> identifiers in <code>Profile.Data</code> and rewarding the player at the same time, then waiting for <code>Profile.LastSavedData</code> to be updated while yielding the response to the <code>MarketplaceService.ProcessReceipt</code> request and, if the <code>PurchaseId</code> is found in <code>Profile.LastSavedData</code> - return <code>Enum.ProductPurchaseDecision.PurchaseGranted</code> for the <code>MarketplaceService.ProcessReceipt</code> callback.</p> <p>This is how you could do it:</p> <pre><code>local Profiles: {[player]: typeof(PlayerStore:StartSessionAsync())} = {} -- See Tutorial &gt; Basic Usage\n\nlocal PURCHASE_ID_CACHE_SIZE = 100\n\nlocal MarketplaceService = game:GetService(\"MarketplaceService\")\nlocal Players = game:GetService(\"Players\")\n\nlocal ProductFunctions = {}\n\nProductFunctions[456456] = function(receipt, player, profile)\n    profile.Data.Cash += 100\n    -- No Profile:Save() is needed in here compared to the previous example\nend\n\nfunction PurchaseIdCheckAsync(profile, purchase_id, grant_product): Enum.ProductPurchaseDecision\n    -- Waits until purchase_id is confirmed to be saved to the DataStore or the profile session has ended\n\n    if profile:IsActive() == true then\n\n        local purchase_id_cache = profile.Data.PurchaseIdCache\n\n        if purchase_id_cache == nil then\n            purchase_id_cache = {}\n            profile.Data.PurchaseIdCache = purchase_id_cache\n        end\n\n        -- Granting product if not received:\n\n        if table.find(purchase_id_cache, purchase_id) == nil then\n\n            local success, result = pcall(grant_product)\n            if success ~= true then\n                warn(`Failed to process receipt:`, profile.Key, purchase_id, result)\n                return Enum.ProductPurchaseDecision.NotProcessedYet\n            end\n\n            while #purchase_id_cache &gt;= PURCHASE_ID_CACHE_SIZE do\n                table.remove(purchase_id_cache, 1)\n            end\n\n            table.insert(purchase_id_cache, purchase_id)\n\n        end\n\n        -- Waiting until the purchase is confirmed to be saved to the DataStore:\n\n        local function is_purchase_saved()\n            local saved_cache = profile.LastSavedData.PurchaseIdCache\n            return if saved_cache ~= nil then table.find(saved_cache, purchase_id) ~= nil else false\n        end\n\n        if is_purchase_saved() == true then\n            return Enum.ProductPurchaseDecision.PurchaseGranted\n        end\n\n        while profile:IsActive() == true do\n\n            local last_saved_data = profile.LastSavedData\n\n            profile:Save()\n\n            if profile.LastSavedData == last_saved_data then\n                profile.OnAfterSave:Wait()\n            end\n\n            if is_purchase_saved() == true then\n                return Enum.ProductPurchaseDecision.PurchaseGranted\n            end\n\n            if profile:IsActive() == true then\n                task.wait(10)\n            end\n\n        end\n\n    end\n\n    return Enum.ProductPurchaseDecision.NotProcessedYet\n\nend\n\nlocal function ProcessReceipt(receipt_info)\n\n    local player = Players:GetPlayerByUserId(receipt_info.PlayerId)\n\n    if player ~= nil then\n\n        local profile = Profiles[player]\n\n        while profile == nil and player.Parent == Players do\n            profile = Profiles[player]\n            if profile ~= nil then\n                break\n            end\n            task.wait()\n        end\n\n        if profile ~= nil then\n\n            if ProductFunctions[receipt_info.ProductId] == nil then\n                warn(`No product function defined for ProductId {receipt_info.ProductId}; Player: {player.Name}`)\n                return Enum.ProductPurchaseDecision.NotProcessedYet\n            end\n\n            return PurchaseIdCheckAsync(\n                profile,\n                receipt_info.PurchaseId,\n                function()\n                    ProductFunctions[receipt_info.ProductId](receipt_info, player, profile)\n                end\n            )\n\n        end\n\n    end\n\n    return Enum.ProductPurchaseDecision.NotProcessedYet\n\nend\n\nMarketplaceService.ProcessReceipt = ProcessReceipt\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Whether you're still writing your game code or already ran into a problem while using ProfileStore, this page can help you avoid some crucial mistakes.</p>"},{"location":"troubleshooting/#problems-in-roblox-studio-testing","title":"Problems in Roblox studio testing","text":"<p>By default, data saved with ProfileStore on Roblox Studio will not persist. This can be changed by enabling studio access to API services.</p> <p>When studio access to API services is enabled, ProfileStore will write to live DataStore keys of the game you're editing (unless ProfileStore.Mock is used) and you might accidentally make unwanted changes to your game's saved data. For more info, check the official documentation.</p>"},{"location":"troubleshooting/#saving-data-which-roblox-cannot-serialize","title":"Saving data which Roblox cannot serialize","text":"<p>ProfileStore does not check <code>Profile.Data</code> for data that cannot be serialized - be aware that the DataStore can only save save data when your tables are devoid of:</p> <ul> <li><code>NaN</code> values - you can check if a number is <code>NaN</code> by comparing it with itself - <code>print(NaN == NaN) --&gt; false</code> (e.g., <code>Profile.Data = {Experience = 0/0}</code>). <code>NaN</code> values are a result of division by zero and edge cases of some math operations (<code>math.acos(2)</code> is <code>-NaN</code>).</li> <li>Table keys that are neither strings nor numbers (e.g., <code>Profile.Data[game.Workspace] = true</code>).</li> <li>Mixing string keys with number keys within the same table (e.g., <code>Profile.Data = {Coins = 100, [5] = \"yes\"}</code>).</li> <li>Storing tables with non-sequential indexes (e.g., <code>Profile.Data = {[1] = \"Apple\", [2] = \"Banana\", [3546] = \"Peanut\"}</code>). If you really have to store non-sequential numbers as indexes, you will have to turn those numbers into <code>string</code> indexes: <code>Profile.Data.Friends[tostring(user_id)] = {GoodFriend = true}</code>.</li> <li>Storing cyclic tables (e.g., <code>Profile.Data = {Self = Profile.Data}</code>).</li> <li>Storing any <code>userdata</code> including <code>Instance</code>, <code>Vector3</code>, <code>CFrame</code>, <code>Udim2</code>, etc. Check whether your value is a <code>userdata</code> by running <code>print(type(value) == \"userdata\")</code> (e.g., <code>Profile.Data = {LastPosition = Vector3.new(0, 0, 0)}</code>) - For storage, you will have to manually convert your <code>userdata</code> to tables, numbers and strings for storage (e.g., <code>Profile.Data = {LastPosition = {position.X, position.Y, position.Z} }</code>).</li> </ul> <p>This is a limitation of the DataStore API - the service ProfileStore is based on.</p> <p>When these data types are present in <code>Profile.Data</code> you may get DataStore errors and ProfileStore will fail to save that data</p>"},{"location":"troubleshooting/#profiles-take-too-long-to-load","title":"Profiles take too long to load","text":"<p>If your profiles are loading slower than 5 seconds, they're loading too slow.</p> <p>(MAKE SURE YOUR ProfileStore MODULE IS UP TO DATE)</p> <p>Possible reasons for this:</p> <ul> <li>You're not running the latest version of ProfileStore (click here to update)</li> <li>You're not calling <code>Profile:EndSession()</code> after you're done working with profiles</li> <li>You're not releasing your profiles immediately after the player leaves the game</li> </ul> <p>Functions connected to Players.PlayerRemoving can be tricky to notice errors for because, when testing alone, you will be leaving the game before the errors appear on the developer console.</p> <p>If a player hops to another server (Server 2) before the previous one (Server 1) calls <code>Profile:EndSession()</code> on the player's profile, Server 2 will wait until Server 1 releases the profile. This may slow down session starting for profiles when the player hops servers.</p> <p>The <code>print()</code> function can help you diagnose whether <code>Profile:EndSession()</code> is called on time:</p> <pre><code>Profile.OnSessionEnd:Connect(function()\n  print(`Profile session has ended ({Profile.Key}) - Profile.Data will no longer be saved to the DataStore`)\nend)\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#getting-profilestore","title":"Getting ProfileStore","text":"<p>ProfileStore is supposed to be a ModuleScript which you should place inside your Roblox game's ServerScriptService or wherever else is preferred. Since DataStores are server-side only, ProfileStore is also a module that should only run on the server-side.</p>"},{"location":"tutorial/#option-1-get-profilestore-from-the-roblox-library","title":"Option #1: Get ProfileStore from the Roblox library","text":"<ul> <li>Get the library model (click here)</li> <li>Make sure the \"ProfileStore\" ModuleScript is under <code>ServerScriptService</code>:</li> </ul>"},{"location":"tutorial/#option-2-github","title":"Option #2: Github","text":"<ul> <li>ProfileStore repository</li> </ul>"},{"location":"tutorial/#basic-usage","title":"Basic Usage","text":"<p>To start using ProfileStore, you need a piece of code that starts a profile session when a player joins. When a profile session is started, changes to the <code>Profile.Data</code> table will be auto-saved periodically and saved for the last time after <code>Profile:EndSession()</code> is called. You can find explanations for every method and property of <code>ProfileStore</code> and <code>Profile</code> objects in the ProfileStore API.</p> <p>This code is a standard implementation of ProfileStore:</p> <pre><code>local ProfileStore = require(game.ServerScriptService.ProfileStore)\n\n-- The PROFILE_TEMPLATE table is what new profile \"Profile.Data\" will default to:\nlocal PROFILE_TEMPLATE = {\n   Cash = 0,\n   Items = {},\n}\n\nlocal Players = game:GetService(\"Players\")\n\nlocal PlayerStore = ProfileStore.New(\"PlayerStore\", PROFILE_TEMPLATE)\nlocal Profiles: {[Player]: typeof(PlayerStore:StartSessionAsync())} = {}\n\nlocal function PlayerAdded(player)\n\n   -- Start a profile session for this player's data:\n\n   local profile = PlayerStore:StartSessionAsync(`{player.UserId}`, {\n      Cancel = function()\n         return player.Parent ~= Players\n      end,\n   })\n\n   -- Handling new profile session or failure to start it:\n\n   if profile ~= nil then\n\n      profile:AddUserId(player.UserId) -- GDPR compliance\n      profile:Reconcile() -- Fill in missing variables from PROFILE_TEMPLATE (optional)\n\n      profile.OnSessionEnd:Connect(function()\n         Profiles[player] = nil\n         player:Kick(`Profile session end - Please rejoin`)\n      end)\n\n      if player.Parent == Players then\n         Profiles[player] = profile\n         print(`Profile loaded for {player.DisplayName}!`)\n         -- EXAMPLE: Grant the player 100 coins for joining:\n         profile.Data.Cash += 100\n         -- You should set \"Cash\" in PROFILE_TEMPLATE and use \"Profile:Reconcile()\",\n         -- otherwise you'll have to check whether \"Data.Cash\" is not nil\n      else\n         -- The player has left before the profile session started\n         profile:EndSession()\n      end\n\n   else\n      -- This condition should only happen when the Roblox server is shutting down\n      player:Kick(`Profile load fail - Please rejoin`)\n   end\n\nend\n\n-- In case Players have joined the server earlier than this script ran:\nfor _, player in Players:GetPlayers() do\n   task.spawn(PlayerAdded, player)\nend\n\nPlayers.PlayerAdded:Connect(PlayerAdded)\n\nPlayers.PlayerRemoving:Connect(function(player)\n   local profile = Profiles[player]\n   if profile ~= nil then\n      profile:EndSession()\n   end\nend)\n</code></pre>"}]}